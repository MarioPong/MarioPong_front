<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>Game Selection</title>
  <link rel="stylesheet" href="css/style_gameSelect.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js" crossorigin="anonymous"></script>
  <script>
    let Ownedcharacters = JSON.parse(localStorage.getItem('characters') || '["Mario"]');
    const owned = Ownedcharacters;
    function startGame(mode) {
      if (mode === 'single') {
        window.location.href = 'marioPong.html';
      }
    }
    function showMultiModal() {
      document.getElementById('multiModal').style.display = 'flex';
      setTimeout(initCustomDropdowns, 0);
      var card = document.querySelector('.game-select-card');
      if (card) card.style.display = 'none';
    }
    function closeMultiModal() {
      document.getElementById('multiModal').style.display = 'none';
      var card = document.querySelector('.game-select-card');
      if (card) card.style.display = '';
    }
    function goBack() {
      window.location.href = 'main.html';
    }
  </script>
</head>

<body>
  <div class="game-select-bg">
    <div class="game-select-card">
      <div class="game-select-header">
        <button class="back-btn" onclick="goBack()">Back</button>
        <span class="game-select-title">Select Game Mode</span>
      </div>
      <div class="game-mode-selection">
        <div class="mode-buttons">
          <button class="mode-btn" onclick="startGame('single')">Single Player</button>
          <button class="mode-btn" onclick="showMultiModal()">Multi Player</button>
        </div>
      </div>
    </div>
    <div class="multi-modal-bg" id="multiModal"
      style="display:none; flex-direction:column; justify-content:center; align-items:center;">
      <div class="multi-modal-card ready-modal">
        <button class="ready-close-btn" id="readyCloseBtn" onclick="closeMultiModal()">×</button>
        <div class="ready-header">Ready</div>
        <div class="ready-room-row">
          <span class="ready-room-label">Enter:</span>
          <input id="roomInput" class="ready-room-input" type="text" placeholder="Enter Room" />
          <button id="makeJoinBtn" class="ready-room-btn">Make/Join</button>
        </div>
        <div class="ready-main-row">
          <div class="ready-player-col">
            <div class="ready-player-label"><span id="player1Name">P1</span>(<span class="ready-check"
                id="player1Status">❌</span>)</div>
            <div class="ready-player-img-box">
              <img src="img/character/mario.png" class="ready-player-img" alt="Mario" />
            </div>
            <div class="custom-character-dropdown" data-player="1"></div>
          </div>
          <div class="ready-center-col">
            <div class="ready-room-name" id="roomName">(Room name)</div>
            <button class="ready-action-btn" id="readyBtnCenter">Ready</button>
            <button class="ready-action-btn leave" id="leaveBtnCenter">Leave</button>
          </div>
          <div class="ready-player-col">
            <div class="ready-player-label"><span id="player2Name">P2</span>(<span class="ready-x"
                id="player2Status">❌</span>)</div>
            <div class="ready-player-img-box">
              <img src="img/character/mario.png" class="ready-player-img" alt="Mario" />
            </div>
            <div class="custom-character-dropdown" data-player="2"></div>
          </div>
        </div>
        <div id="roomInfoBox" style="margin-bottom:10px; font-size:1.1em;"></div>
        <div id="status" style="min-height:24px;"></div>
        <div id="error" style="color:#e04d45; text-align:center; margin-top:24px; font-size:1.1em;"></div>

        <!-- 게임 화면 -->
        <div id="gameScreen"
          style="display:none; width:100%; justify-content:center; align-items:center; flex-direction:column;">
          <canvas id="pongCanvas"
            style="background:#000; border:2px solid #fff; width:100%; max-width:600px; height:400px; max-height:60vh;"></canvas>
          <button id="exitGameBtn" class="ready-action-btn leave" style="margin-top:16px;">게임 나가기</button>
          <div id="skillBarContainer" style="margin-top:12px; width:240px; height:24px;">
            <div id="skillBarBg" style="width:100%;height:100%;background:#444;border-radius:12px;">
              <div id="skillBar"
                style="width:0%;height:100%;background:#3fcf3f;border-radius:12px;transition:width 0.2s;"></div>
            </div>
            <div id="skillLabel"
              style="position:absolute;top:0;left:0;width:100%;height:100%;text-align:center;line-height:24px;color:#fff;font-size:1.1em;font-weight:bold;">
              스킬 쿨타임</div>
          </div>
        </div>

        <!-- 결과 모달 -->
        <div id="resultModal" class="multi-modal-card"
          style="display:none; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; color:#222; border-radius:12px; padding:40px 60px; text-align:center; min-width:280px; box-shadow:0 8px 32px rgba(0,0,0,0.4); z-index:1100;">
          <div id="resultBox">
            <h2 id="resultTitle"></h2>
            <p id="resultScore"></p>
            <button id="toLobbyBtn" class="ready-action-btn">로비로 돌아가기</button>
          </div>
        </div>
      </div>
    </div>
    <div id="blindOverlay"
      style="display:none; position:absolute; top:0; left:0; width:100vw; height:100vh; z-index:1000; background:rgba(0,0,0,0.7); justify-content:center; align-items:center;">
      <img src="./img/item/blooper.png" style="max-width:80vw; max-height:80vh; opacity:0.95;">
    </div>
  </div>
  <script>
    // function goBack() {
    //   window.location.href = 'main.html';
    // }

    // ====== 설정 ======
    const socket = io('https://mariopong-back-4cre.onrender.com/pong');
    let joined = false;
    let currentRoom = null;
    let myPaddleIndex = null;
    let gameActive = false;
    let playerIndex = 2;
    let userName = localStorage.getItem('userName') || '익명';
    let characters = JSON.parse(localStorage.getItem('characters') || '["Mario"]');
    let skillCooldown = 10; // 기본값, 캐릭터에 따라 변경
    let lastSkillTime = 0;
    let skillReady = false;
    let myCharacter = localStorage.getItem('character_now') || characters[0];

    // ====== 화면 요소 ======
    const lobbyScreen = document.getElementById('lobbyScreen');
    const gameScreen = document.getElementById('gameScreen');
    const statusDiv = document.getElementById('status');
    const errorDiv = document.getElementById('error');
    const readyBtn = document.getElementById('readyBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const exitGameBtn = document.getElementById('exitGameBtn');
    const canvas = document.getElementById('pongCanvas');
    const context = canvas.getContext('2d');
    const resultModal = document.getElementById('resultModal');
    const resultTitle = document.getElementById('resultTitle');
    const resultScore = document.getElementById('resultScore');
    const toLobbyBtn = document.getElementById('toLobbyBtn');
    const roomInfoBox = document.getElementById('roomInfoBox');
    const blindOverlay = document.getElementById('blindOverlay');

    // ====== 유틸 ======
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ====== 스킬 쿨타임 바 ======
    function updateSkillBar() {
      const now = Date.now();
      const elapsed = (now - lastSkillTime) / 1000;
      let percent = Math.min(1, elapsed / skillCooldown);
      document.getElementById('skillBar').style.width = (percent * 100) + '%';
      skillReady = percent >= 1;
      document.getElementById('skillLabel').innerText = skillReady ? '스킬 사용 가능! (Space)' : `쿨타임: ${Math.ceil(skillCooldown - elapsed)}초`;
    }
    setInterval(updateSkillBar, 100);

    // ====== 방 입장/생성 ======
    function joinRoom(roomName) {
      if (!roomName) {
        errorDiv.innerText = 'Please enter the room name.';
        return;
      }
      socket.emit('joinRoom', roomName, userName);
      errorDiv.innerText = '';
      currentRoom = roomName;
    }
    document.getElementById('makeJoinBtn').onclick = () => {
      const roomName = document.getElementById('roomInput').value.trim();
      if (!roomName) {
        errorDiv.innerText = 'Please enter the room name.';
        return;
      }
      joinRoom(roomName);
      // (Room name) 자리에 입력한 방 이름 표시
      const roomNameDiv = document.getElementById('roomName');
      if (roomNameDiv) roomNameDiv.textContent = roomName;
    };
    leaveBtn.onclick = () => {
      if (joined && currentRoom) {
        socket.emit('leaveRoom', currentRoom);
        statusDiv.innerText = 'You left the room.';
        readyBtn.disabled = true;
        leaveBtn.disabled = true;
        joined = false;
        currentRoom = null;
        showLobby();
        roomInfoBox.innerHTML = '';
      }
    };
    readyBtn.onclick = () => {
      socket.emit('ready', myCharacter);
      statusDiv.innerText = 'Ready! Waiting for...';
      readyBtn.disabled = true;
    };
    exitGameBtn.onclick = () => {
      socket.emit('leaveRoom', currentRoom);
      readyBtn.disabled = true;
      leaveBtn.disabled = true;
      joined = false;
      currentRoom = null;
      showLobby();
      roomInfoBox.innerHTML = '';
    };

    // ====== 스킬 발동 ======
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && skillReady && gameActive) {
        socket.emit('useSkill');
        lastSkillTime = Date.now();
        skillReady = false;
        updateSkillBar();
      }
    });

    // ====== 화면 전환 ======
    function showLobby() {
      gameScreen.style.display = 'none';
      // lobbyScreen.style.display = 'flex'; // This line is removed as per new HTML structure
      readyBtn.disabled = false;
      leaveBtn.disabled = false;
      statusDiv.innerText = '';
      gameActive = false;
      context.clearRect(0, 0, canvas.width, canvas.height);
      hideResultModal();
      socket.emit('requestRoomInfo');
      roomInfoBox.style.display = 'block';
    }
    function showGame() {
      // lobbyScreen.style.display = 'none'; // This line is removed as per new HTML structure
      gameScreen.style.display = 'flex';
      gameActive = true;
      resizeCanvas();
      lastSkillTime = Date.now() - skillCooldown * 1000; // 게임 시작시 스킬 바로 사용 가능
    }

    // ====== 결과 모달 ======
    function showResultModal(winner, score) {
      resultTitle.innerText = (myPaddleIndex === winner) ? "Win!" : "Loose!";
      resultScore.innerText = `Score: ${score[0]} : ${score[1]}`;
      resultModal.style.display = 'flex';
    }
    function hideResultModal() {
      resultModal.style.display = 'none';
    }
    toLobbyBtn.onclick = () => {
      showLobby();
    };

    // ====== 소켓 이벤트 ======
    socket.on('roomFull', (data) => {
      errorDiv.innerText = data.message;
    });
    socket.on('enteredRoom', (index) => {
      statusDiv.innerText = 'You have entered the room. Please push the ready button.';
      readyBtn.disabled = false;
      leaveBtn.disabled = false;
      joined = true;
      playerIndex = index;
    });
    socket.on('connect', () => {
      statusDiv.innerText = 'Server connected';
    });
    socket.on('disconnect', () => {
      statusDiv.innerText = 'Server disconnected';
      readyBtn.disabled = true;
      leaveBtn.disabled = true;
      joined = false;
      currentRoom = null;
      showLobby();
    });
    socket.on('connect_error', (err) => {
      errorDiv.innerText = 'Connection error: ' + err.message;
    });
    socket.on('waiting', (data) => {
      if (socket.id === data) {
        statusDiv.innerText = 'Ready! Waiting for...';
      }
    });
    socket.on('startGame', () => {
      showGame();
      statusDiv.innerText = '';
      socket.emit('getPaddleIndex', currentRoom);
    });
    socket.on('gameState', (state) => {
      window.lastGameState = state;
      renderGame(state);
    });
    socket.on('paddleIndex', (idx) => {
      myPaddleIndex = idx;
    });
    socket.on('gameOver', (data) => {
      gameActive = false;
      showResultModal(data.winner, data.score);
    });
    socket.on('componentLeft', (id) => {
      if (socket.id !== id) {
        socket.emit('leaveRoom', currentRoom);
        showLobby();
      }
    });
    socket.on('roomInfo', (players) => {
      if (!players || players.length === 0) {
        roomInfoBox.innerHTML = '';
        return;
      }
      let html = `<strong>Room: ${currentRoom}</strong><br>`;
      players.forEach((p, i) => {
        // 내 소켓 ID와 비교해 내 영역에만 select 표시
        if (p.id === socket.id) {
          html += `P${i + 1}: ${p.userName} (${p.ready ? '✅' : '❌'})<br>`;
          html += `<select id="characterSelect">
            ${characters.map(ch => `<option value="${ch}" ${p.character === ch ? 'selected' : ''}>${ch}</option>`).join('')}
          </select><br>`;
        } else {
          html += `P${i + 1}: ${p.userName} (${p.ready ? '✅' : '❌'}) - <span>${p.character || 'Not selected'}</span><br>`;
        }
      });
      roomInfoBox.innerHTML = html;

      const select = document.getElementById('characterSelect');
      if (select) {
        select.onchange = function () {
          myCharacter = select.value;
          socket.emit('selectCharacter', select.value);
          localStorage.setItem('character_now', select.value);
          skillCooldown = 10;
        };
      }
    });
    socket.on('blindEffect', ({ duration }) => {
      blindOverlay.style.display = 'flex';
      setTimeout(() => {
        blindOverlay.style.display = 'none';
      }, duration || 1000);
    });

    // ====== 게임 화면 ======
    function renderGame(state) {
      context.clearRect(0, 0, canvas.width, canvas.height);

      const cw = canvas.width, ch = canvas.height;
      // 서버에서 받은 패들 크기 사용
      const paddleWidth0 = (state.paddleWidth ? state.paddleWidth[0] : 10) / 700 * cw;
      const paddleWidth1 = (state.paddleWidth ? state.paddleWidth[1] : 10) / 700 * cw;
      const paddleHeight0 = (state.paddleHeight ? state.paddleHeight[0] : 75) / 500 * ch;
      const paddleHeight1 = (state.paddleHeight ? state.paddleHeight[1] : 75) / 500 * ch;

      const paddleY0 = state.paddleY ? state.paddleY[0] / 500 * ch : ch / 2 - paddleHeight0 / 2;
      const paddleY1 = state.paddleY ? state.paddleY[1] / 500 * ch : ch / 2 - paddleHeight1 / 2;
      const paddleX0 = cw * 0.03;
      const paddleX1 = cw - paddleWidth1 - cw * 0.03;

      context.fillStyle = 'black';
      context.fillRect(0, 0, cw, ch);

      context.beginPath();
      context.setLineDash([4]);
      context.moveTo(cw / 2, 0);
      context.lineTo(cw / 2, ch);
      context.strokeStyle = 'grey';
      context.stroke();

      context.setLineDash([]);
      context.fillStyle = 'white';
      context.fillRect(paddleX0, paddleY0, paddleWidth0, paddleHeight0);
      context.fillRect(paddleX1, paddleY1, paddleWidth1, paddleHeight1);

      const ballX = (state.ballX / 700) * cw;
      const ballY = (state.ballY / 500) * ch;
      context.beginPath();
      context.arc(ballX, ballY, Math.min(cw, ch) * 0.02, 0, 2 * Math.PI, false);
      context.fillStyle = 'white';
      context.fill();

      for (const ball of state.fakeBalls) {
        context.beginPath();
        context.arc(ball.x, ball.y, Math.min(cw, ch) * 0.02, 0, 2 * Math.PI, false);
        context.fill();
      }
      context.globalAlpha = 1.0;

      context.font = `${Math.floor(ch * 0.08)}px Courier New`;
      context.fillText(state.score ? state.score[0] : 0, cw * 0.25, ch * 0.1);
      context.fillText(state.score ? state.score[1] : 0, cw * 0.75, ch * 0.1);
    }

    // ====== 패들 조작(마우스/터치) ======
    canvas.addEventListener('mousemove', (e) => {
      if (!gameActive || myPaddleIndex === null) return;
      const rect = canvas.getBoundingClientRect();
      let y = e.clientY - rect.top;
      const ch = canvas.height;

      const paddleHeight = (window.lastGameState && window.lastGameState.paddleHeight)
        ? window.lastGameState.paddleHeight[myPaddleIndex] / 500 * ch
        : ch * 0.15;
      y = Math.max(0, Math.min(y, ch - paddleHeight));
      const yServer = y / ch * 500;
      socket.emit('paddleMove', { yPosition: yServer });
    });
    canvas.addEventListener('touchmove', (e) => {
      if (!gameActive || myPaddleIndex === null) return;
      const rect = canvas.getBoundingClientRect();
      let y = e.touches[0].clientY - rect.top;
      const ch = canvas.height;
      const paddleHeight = (window.lastGameState && window.lastGameState.paddleHeight)
        ? window.lastGameState.paddleHeight[myPaddleIndex] / 500 * ch
        : ch * 0.15;
      y = Math.max(0, Math.min(y, ch - paddleHeight));
      const yServer = y / ch * 500;
      socket.emit('paddleMove', { yPosition: yServer });
      e.preventDefault();
    }, { passive: false });

    window.addEventListener('DOMContentLoaded', resizeCanvas);
  </script>
</body>

</html>